{"ast":null,"code":"/**\n * @license NgRx 8.6.1\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { Injectable, InjectionToken, Inject, isDevMode, NgModule, Optional, SkipSelf, Injector } from '@angular/core';\nimport { BehaviorSubject, Observable, Subject, queueScheduler } from 'rxjs';\nimport { observeOn, withLatestFrom, scan, pluck, map, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * \\@usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n * @template T, C\n * @param {?} type Describes the action that will be dispatched\n * @param {?=} config Additional metadata needed for the handling of the action.  See {\\@link createAction#usage-notes Usage Notes}.\n *\n * @return {?}\n */\nfunction createAction(type, config) {\n  if (typeof config === 'function') {\n    return defineType(type,\n    /**\n    * @param {...?} args\n    * @return {?}\n    */\n    (...args) => Object.assign({}, config(...args), {\n      type\n    }));\n  }\n  /** @type {?} */\n  const as = config ? config._as : 'empty';\n  switch (as) {\n    case 'empty':\n      return defineType(type,\n      /**\n      * @return {?}\n      */\n      () => ({\n        type\n      }));\n    case 'props':\n      return defineType(type,\n      /**\n      * @param {?} props\n      * @return {?}\n      */\n      props => Object.assign({}, props, {\n        type\n      }));\n    default:\n      throw new Error('Unexpected config.');\n  }\n}\n/**\n * @template P\n * @return {?}\n */\nfunction props() {\n  // the return type does not match TypePropertyIsNotAllowed, so double casting\n  // is used.\n  return /** @type {?} */ /** @type {?} */{\n    _as: 'props',\n    _p: ( /** @type {?} */undefined)\n  };\n}\n/**\n * @template C\n * @param {?} creators\n * @return {?}\n */\nfunction union(creators) {\n  return /** @type {?} */undefined;\n}\n/**\n * @param {?} type\n * @param {?} creator\n * @return {?}\n */\nfunction defineType(type, creator) {\n  return Object.defineProperty(creator, 'type', {\n    value: type,\n    writable: false\n  });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst INIT = /** @type {?} */'@ngrx/store/init';\nclass ActionsSubject extends BehaviorSubject {\n  constructor() {\n    super({\n      type: INIT\n    });\n  }\n  /**\n   * @param {?} action\n   * @return {?}\n   */\n  next(action) {\n    if (typeof action === 'function') {\n      throw new TypeError(`\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().`);\n    } else if (typeof action === 'undefined') {\n      throw new TypeError(`Actions must be objects`);\n    } else if (typeof action.type === 'undefined') {\n      throw new TypeError(`Actions must have a type property`);\n    }\n    super.next(action);\n  }\n  /**\n   * @return {?}\n   */\n  complete() {\n    /* noop */\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    super.complete();\n  }\n}\n\n/** @nocollapse */\n\n/** @type {?} */\nconst ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst _ROOT_STORE_GUARD = new InjectionToken('@ngrx/store Internal Root Guard');\n/** @type {?} */\nconst _INITIAL_STATE = new InjectionToken('@ngrx/store Internal Initial State');\n/** @type {?} */\nconst INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\n/** @type {?} */\nconst REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory');\n/** @type {?} */\nconst _REDUCER_FACTORY = new InjectionToken('@ngrx/store Internal Reducer Factory Provider');\n/** @type {?} */\nconst INITIAL_REDUCERS = new InjectionToken('@ngrx/store Initial Reducers');\n/** @type {?} */\nconst _INITIAL_REDUCERS = new InjectionToken('@ngrx/store Internal Initial Reducers');\n/** @type {?} */\nconst STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\n/** @type {?} */\nconst _STORE_REDUCERS = new InjectionToken('@ngrx/store Internal Store Reducers');\n/** @type {?} */\nconst _FEATURE_REDUCERS = new InjectionToken('@ngrx/store Internal Feature Reducers');\n/** @type {?} */\nconst _FEATURE_CONFIGS = new InjectionToken('@ngrx/store Internal Feature Configs');\n/** @type {?} */\nconst _STORE_FEATURES = new InjectionToken('@ngrx/store Internal Store Features');\n/** @type {?} */\nconst _FEATURE_REDUCERS_TOKEN = new InjectionToken('@ngrx/store Internal Feature Reducers Token');\n/** @type {?} */\nconst FEATURE_REDUCERS = new InjectionToken('@ngrx/store Feature Reducers');\n/**\n * User-defined meta reducers from StoreModule.forRoot()\n * @type {?}\n */\nconst USER_PROVIDED_META_REDUCERS = new InjectionToken('@ngrx/store User Provided Meta Reducers');\n/**\n * Meta reducers defined either internally by \\@ngrx/store or by library authors\n * @type {?}\n */\nconst META_REDUCERS = new InjectionToken('@ngrx/store Meta Reducers');\n/**\n * Concats the user provided meta reducers and the meta reducers provided on the multi\n * injection token\n * @type {?}\n */\nconst _RESOLVED_META_REDUCERS = new InjectionToken('@ngrx/store Internal Resolved Meta Reducers');\n/**\n * Runtime checks defined by the user via an InjectionToken\n * Defaults to `_USER_RUNTIME_CHECKS`\n * @type {?}\n */\nconst USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store User Runtime Checks Config');\n/**\n * Runtime checks defined by the user via forRoot()\n * @type {?}\n */\nconst _USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal User Runtime Checks Config');\n/**\n * Runtime checks currently in use\n * @type {?}\n */\nconst _ACTIVE_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal Runtime Checks');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} reducers\n * @param {?=} initialState\n * @return {?}\n */\nfunction combineReducers(reducers, initialState = {}) {\n  /** @type {?} */\n  const reducerKeys = Object.keys(reducers);\n  /** @type {?} */\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    /** @type {?} */\n    const key = reducerKeys[i];\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  /** @type {?} */\n  const finalReducerKeys = Object.keys(finalReducers);\n  return (\n    /**\n    * @param {?} state\n    * @param {?} action\n    * @return {?}\n    */\n    function combination(state, action) {\n      state = state === undefined ? initialState : state;\n      /** @type {?} */\n      let hasChanged = false;\n      /** @type {?} */\n      const nextState = {};\n      for (let i = 0; i < finalReducerKeys.length; i++) {\n        /** @type {?} */\n        const key = finalReducerKeys[i];\n        /** @type {?} */\n        const reducer = finalReducers[key];\n        /** @type {?} */\n        const previousStateForKey = state[key];\n        /** @type {?} */\n        const nextStateForKey = reducer(previousStateForKey, action);\n        nextState[key] = nextStateForKey;\n        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n      }\n      return hasChanged ? nextState : state;\n    }\n  );\n}\n/**\n * @template T\n * @param {?} object\n * @param {?} keyToRemove\n * @return {?}\n */\nfunction omit(object, keyToRemove) {\n  return Object.keys(object).filter(\n  /**\n  * @param {?} key\n  * @return {?}\n  */\n  key => key !== keyToRemove).reduce(\n  /**\n  * @param {?} result\n  * @param {?} key\n  * @return {?}\n  */\n  (result, key) => Object.assign(result, {\n    [key]: object[key]\n  }), {});\n}\n/**\n * @param {...?} functions\n * @return {?}\n */\nfunction compose(...functions) {\n  return (\n    /**\n    * @param {?} arg\n    * @return {?}\n    */\n    function (arg) {\n      if (functions.length === 0) {\n        return arg;\n      }\n      /** @type {?} */\n      const last = functions[functions.length - 1];\n      /** @type {?} */\n      const rest = functions.slice(0, -1);\n      return rest.reduceRight(\n      /**\n      * @param {?} composed\n      * @param {?} fn\n      * @return {?}\n      */\n      (composed, fn) => fn(composed), last(arg));\n    }\n  );\n}\n/**\n * @template T, V\n * @param {?} reducerFactory\n * @param {?=} metaReducers\n * @return {?}\n */\nfunction createReducerFactory(reducerFactory, metaReducers) {\n  if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n    /** @type {?} */reducerFactory = compose.apply(null, [...metaReducers, reducerFactory]);\n  }\n  return (\n    /**\n    * @param {?} reducers\n    * @param {?=} initialState\n    * @return {?}\n    */\n    (reducers, initialState) => {\n      /** @type {?} */\n      const reducer = reducerFactory(reducers);\n      return (\n        /**\n        * @param {?} state\n        * @param {?} action\n        * @return {?}\n        */\n        (state, action) => {\n          state = state === undefined ? ( /** @type {?} */initialState) : state;\n          return reducer(state, action);\n        }\n      );\n    }\n  );\n}\n/**\n * @template T, V\n * @param {?=} metaReducers\n * @return {?}\n */\nfunction createFeatureReducerFactory(metaReducers) {\n  /** @type {?} */\n  const reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0 ? compose(...metaReducers) : (\n  /**\n  * @param {?} r\n  * @return {?}\n  */\n  r => r);\n  return (\n    /**\n    * @param {?} reducer\n    * @param {?=} initialState\n    * @return {?}\n    */\n    (reducer, initialState) => {\n      reducer = reducerFactory(reducer);\n      return (\n        /**\n        * @param {?} state\n        * @param {?} action\n        * @return {?}\n        */\n        (state, action) => {\n          state = state === undefined ? initialState : state;\n          return reducer(state, action);\n        }\n      );\n    }\n  );\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n */\nclass ReducerObservable extends Observable {}\n/**\n * @abstract\n */\nclass ReducerManagerDispatcher extends ActionsSubject {}\n/** @type {?} */\nconst UPDATE = /** @type {?} */'@ngrx/store/update-reducers';\nclass ReducerManager extends BehaviorSubject {\n  /**\n   * @param {?} dispatcher\n   * @param {?} initialState\n   * @param {?} reducers\n   * @param {?} reducerFactory\n   */\n  constructor(dispatcher, initialState, reducers, reducerFactory) {\n    super(reducerFactory(reducers, initialState));\n    this.dispatcher = dispatcher;\n    this.initialState = initialState;\n    this.reducers = reducers;\n    this.reducerFactory = reducerFactory;\n  }\n  /**\n   * @param {?} feature\n   * @return {?}\n   */\n  addFeature(feature) {\n    this.addFeatures([feature]);\n  }\n  /**\n   * @param {?} features\n   * @return {?}\n   */\n  addFeatures(features) {\n    /** @type {?} */\n    const reducers = features.reduce(\n    /**\n    * @param {?} reducerDict\n    * @param {?} __1\n    * @return {?}\n    */\n    (reducerDict, {\n      reducers,\n      reducerFactory,\n      metaReducers,\n      initialState,\n      key\n    }) => {\n      /** @type {?} */\n      const reducer = typeof reducers === 'function' ? createFeatureReducerFactory(metaReducers)(reducers, initialState) : createReducerFactory(reducerFactory, metaReducers)(reducers, initialState);\n      reducerDict[key] = reducer;\n      return reducerDict;\n    }, /** @type {?} */{});\n    this.addReducers(reducers);\n  }\n  /**\n   * @param {?} feature\n   * @return {?}\n   */\n  removeFeature(feature) {\n    this.removeFeatures([feature]);\n  }\n  /**\n   * @param {?} features\n   * @return {?}\n   */\n  removeFeatures(features) {\n    this.removeReducers(features.map(\n    /**\n    * @param {?} p\n    * @return {?}\n    */\n    p => p.key));\n  }\n  /**\n   * @param {?} key\n   * @param {?} reducer\n   * @return {?}\n   */\n  addReducer(key, reducer) {\n    this.addReducers({\n      [key]: reducer\n    });\n  }\n  /**\n   * @param {?} reducers\n   * @return {?}\n   */\n  addReducers(reducers) {\n    this.reducers = Object.assign({}, this.reducers, reducers);\n    this.updateReducers(Object.keys(reducers));\n  }\n  /**\n   * @param {?} featureKey\n   * @return {?}\n   */\n  removeReducer(featureKey) {\n    this.removeReducers([featureKey]);\n  }\n  /**\n   * @param {?} featureKeys\n   * @return {?}\n   */\n  removeReducers(featureKeys) {\n    featureKeys.forEach(\n    /**\n    * @param {?} key\n    * @return {?}\n    */\n    key => {\n      this.reducers = /** @type {?} */omit(this.reducers, key) /*TODO(#823)*/;\n    });\n    this.updateReducers(featureKeys);\n  }\n  /**\n   * @private\n   * @param {?} featureKeys\n   * @return {?}\n   */\n  updateReducers(featureKeys) {\n    this.next(this.reducerFactory(this.reducers, this.initialState));\n    this.dispatcher.next( /** @type {?} */{\n      type: UPDATE,\n      features: featureKeys\n    });\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n\n/** @nocollapse */\n\n/** @type {?} */\nconst REDUCER_MANAGER_PROVIDERS = [ReducerManager, {\n  provide: ReducerObservable,\n  useExisting: ReducerManager\n}, {\n  provide: ReducerManagerDispatcher,\n  useExisting: ActionsSubject\n}];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScannedActionsSubject extends Subject {\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n/** @type {?} */\nconst SCANNED_ACTIONS_SUBJECT_PROVIDERS = [ScannedActionsSubject];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n */\nclass StateObservable extends Observable {}\n/**\n * @template T\n */\nlet State = /*#__PURE__*/(() => {\n  class State extends BehaviorSubject {\n    /**\n     * @param {?} actions$\n     * @param {?} reducer$\n     * @param {?} scannedActions\n     * @param {?} initialState\n     */\n    constructor(actions$, reducer$, scannedActions, initialState) {\n      super(initialState);\n      /** @type {?} */\n      const actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n      /** @type {?} */\n      const withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n      /** @type {?} */\n      const seed = {\n        state: initialState\n      };\n      /** @type {?} */\n      const stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n      this.stateSubscription = stateAndAction$.subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        state,\n        action\n      }) => {\n        this.next(state);\n        scannedActions.next(action);\n      });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.stateSubscription.unsubscribe();\n      this.complete();\n    }\n  }\n  State.INIT = INIT;\n\n  /** @nocollapse */\n  return State;\n})();\n/**\n * @template T, V\n * @param {?=} stateActionPair\n * @param {?=} __1\n * @return {?}\n */\nfunction reduceState(stateActionPair = {\n  state: undefined\n}, [action, reducer]) {\n  const {\n    state\n  } = stateActionPair;\n  return {\n    state: reducer(state, action),\n    action\n  };\n}\n/** @type {?} */\nconst STATE_PROVIDERS = [State, {\n  provide: StateObservable,\n  useExisting: State\n}];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n */\nclass Store extends Observable {\n  /**\n   * @param {?} state$\n   * @param {?} actionsObserver\n   * @param {?} reducerManager\n   */\n  constructor(state$, actionsObserver, reducerManager) {\n    super();\n    this.actionsObserver = actionsObserver;\n    this.reducerManager = reducerManager;\n    this.source = state$;\n  }\n  /**\n   * @template Props, K\n   * @param {?} pathOrMapFn\n   * @param {...?} paths\n   * @return {?}\n   */\n  select(pathOrMapFn, ...paths) {\n    return ( /** @type {?} */select).call(null, pathOrMapFn, ...paths)(this);\n  }\n  /**\n   * @template R\n   * @param {?} operator\n   * @return {?}\n   */\n  lift(operator) {\n    /** @type {?} */\n    const store = new Store(this, this.actionsObserver, this.reducerManager);\n    store.operator = operator;\n    return store;\n  }\n  /**\n   * @template V\n   * @param {?} action\n   * @return {?}\n   */\n  dispatch(action) {\n    this.actionsObserver.next(action);\n  }\n  /**\n   * @param {?} action\n   * @return {?}\n   */\n  next(action) {\n    this.actionsObserver.next(action);\n  }\n  /**\n   * @param {?} err\n   * @return {?}\n   */\n  error(err) {\n    this.actionsObserver.error(err);\n  }\n  /**\n   * @return {?}\n   */\n  complete() {\n    this.actionsObserver.complete();\n  }\n  /**\n   * @template State, Actions\n   * @param {?} key\n   * @param {?} reducer\n   * @return {?}\n   */\n  addReducer(key, reducer) {\n    this.reducerManager.addReducer(key, reducer);\n  }\n  /**\n   * @template Key\n   * @param {?} key\n   * @return {?}\n   */\n  removeReducer(key) {\n    this.reducerManager.removeReducer(key);\n  }\n}\n\n/** @nocollapse */\n\n/** @type {?} */\nconst STORE_PROVIDERS = [Store];\n/**\n * @template T, Props, K\n * @param {?} pathOrMapFn\n * @param {?=} propsOrPath\n * @param {...?} paths\n * @return {?}\n */\nfunction select(pathOrMapFn, propsOrPath, ...paths) {\n  return (\n    /**\n    * @param {?} source$\n    * @return {?}\n    */\n    function selectOperator(source$) {\n      /** @type {?} */\n      let mapped$;\n      if (typeof pathOrMapFn === 'string') {\n        /** @type {?} */\n        const pathSlices = [( /** @type {?} */propsOrPath), ...paths].filter(Boolean);\n        mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n      } else if (typeof pathOrMapFn === 'function') {\n        mapped$ = source$.pipe(map(\n        /**\n        * @param {?} source\n        * @return {?}\n        */\n        source => pathOrMapFn(source, /** @type {?} */propsOrPath)));\n      } else {\n        throw new TypeError(`Unexpected type '${typeof pathOrMapFn}' in select operator,` + ` expected 'string' or 'function'`);\n      }\n      return mapped$.pipe(distinctUntilChanged());\n    }\n  );\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction isEqualCheck(a, b) {\n  return a === b;\n}\n/**\n * @param {?} args\n * @param {?} lastArguments\n * @param {?} comparator\n * @return {?}\n */\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n  for (let i = 0; i < args.length; i++) {\n    if (!comparator(args[i], lastArguments[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * @param {?} projectionFn\n * @param {?} isResultEqual\n * @return {?}\n */\nfunction resultMemoize(projectionFn, isResultEqual) {\n  return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\n/**\n * @param {?} projectionFn\n * @param {?=} isArgumentsEqual\n * @param {?=} isResultEqual\n * @return {?}\n */\nfunction defaultMemoize(projectionFn, isArgumentsEqual = isEqualCheck, isResultEqual = isEqualCheck) {\n  /** @type {?} */\n  let lastArguments = null;\n  // tslint:disable-next-line:no-any anything could be the result.\n  /** @type {?} */\n  let lastResult = null;\n  /** @type {?} */\n  let overrideResult;\n  /**\n   * @return {?}\n   */\n  function reset() {\n    lastArguments = null;\n    lastResult = null;\n  }\n  /**\n   * @param {?=} result\n   * @return {?}\n   */\n  function setResult(result = undefined) {\n    overrideResult = result;\n  }\n  // tslint:disable-next-line:no-any anything could be the result.\n  /**\n   * @return {?}\n   */\n  function memoized() {\n    if (overrideResult !== undefined) {\n      return overrideResult;\n    }\n    if (!lastArguments) {\n      lastResult = projectionFn.apply(null, /** @type {?} */arguments);\n      lastArguments = arguments;\n      return lastResult;\n    }\n    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n      return lastResult;\n    }\n    /** @type {?} */\n    const newResult = projectionFn.apply(null, /** @type {?} */arguments);\n    lastArguments = arguments;\n    if (isResultEqual(lastResult, newResult)) {\n      return lastResult;\n    }\n    lastResult = newResult;\n    return newResult;\n  }\n  return {\n    memoized,\n    reset,\n    setResult\n  };\n}\n/**\n * @param {...?} input\n * @return {?}\n */\nfunction createSelector(...input) {\n  return createSelectorFactory(defaultMemoize)(...input);\n}\n/**\n * @param {?} state\n * @param {?} selectors\n * @param {?} props\n * @param {?} memoizedProjector\n * @return {?}\n */\nfunction defaultStateFn(state, selectors, props, memoizedProjector) {\n  if (props === undefined) {\n    /** @type {?} */\n    const args = ( /** @type {?} */selectors).map(\n    /**\n    * @param {?} fn\n    * @return {?}\n    */\n    fn => fn(state));\n    return memoizedProjector.memoized.apply(null, args);\n  }\n  /** @type {?} */\n  const args = ( /** @type {?} */selectors).map(\n  /**\n  * @param {?} fn\n  * @return {?}\n  */\n  fn => fn(state, props));\n  return memoizedProjector.memoized.apply(null, [...args, props]);\n}\n/**\n * @param {?} memoize\n * @param {?=} options\n * @return {?}\n */\nfunction createSelectorFactory(memoize, options = {\n  stateFn: defaultStateFn\n}) {\n  return (\n    /**\n    * @param {...?} input\n    * @return {?}\n    */\n    function (...input) {\n      /** @type {?} */\n      let args = input;\n      if (Array.isArray(args[0])) {\n        const [head, ...tail] = args;\n        args = [...head, ...tail];\n      }\n      /** @type {?} */\n      const selectors = args.slice(0, args.length - 1);\n      /** @type {?} */\n      const projector = args[args.length - 1];\n      /** @type {?} */\n      const memoizedSelectors = selectors.filter(\n      /**\n      * @param {?} selector\n      * @return {?}\n      */\n      selector => selector.release && typeof selector.release === 'function');\n      /** @type {?} */\n      const memoizedProjector = memoize(\n      /**\n      * @param {...?} selectors\n      * @return {?}\n      */\n      function (...selectors) {\n        return projector.apply(null, selectors);\n      });\n      /** @type {?} */\n      const memoizedState = defaultMemoize(\n      /**\n      * @param {?} state\n      * @param {?} props\n      * @return {?}\n      */\n      function (state, props) {\n        return options.stateFn.apply(null, [state, selectors, props, memoizedProjector]);\n      });\n      /**\n       * @return {?}\n       */\n      function release() {\n        memoizedState.reset();\n        memoizedProjector.reset();\n        memoizedSelectors.forEach(\n        /**\n        * @param {?} selector\n        * @return {?}\n        */\n        selector => selector.release());\n      }\n      return Object.assign(memoizedState.memoized, {\n        release,\n        projector: memoizedProjector.memoized,\n        setResult: memoizedState.setResult\n      });\n    }\n  );\n}\n/**\n * @param {?} featureName\n * @return {?}\n */\nfunction createFeatureSelector(featureName) {\n  return createSelector(\n  /**\n  * @param {?} state\n  * @return {?}\n  */\n  state => {\n    /** @type {?} */\n    const featureState = state[featureName];\n    if (isDevMode() && !(featureName in state)) {\n      console.warn(`@ngrx/store: The feature name \\\"${featureName}\\\" does ` + 'not exist in the state, therefore createFeatureSelector ' + 'cannot access it.  Be sure it is imported in a loaded module ' + `using StoreModule.forRoot('${featureName}', ...) or ` + `StoreModule.forFeature('${featureName}', ...).  If the default ` + 'state is intended to be undefined, as is the case with router ' + 'state, this development-only warning message can be ignored.');\n    }\n    return featureState;\n  },\n  /**\n  * @param {?} featureState\n  * @return {?}\n  */\n  featureState => featureState);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isUndefined(target) {\n  return target === undefined;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isNull(target) {\n  return target === null;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isArray(target) {\n  return Array.isArray(target);\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isString(target) {\n  return typeof target === 'string';\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isBoolean(target) {\n  return typeof target === 'boolean';\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isNumber(target) {\n  return typeof target === 'number';\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isObjectLike(target) {\n  return typeof target === 'object' && target !== null;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isObject(target) {\n  return isObjectLike(target) && !isArray(target);\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isPlainObject(target) {\n  if (!isObject(target)) {\n    return false;\n  }\n  /** @type {?} */\n  const targetPrototype = Object.getPrototypeOf(target);\n  return targetPrototype === Object.prototype || targetPrototype === null;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isFunction(target) {\n  return typeof target === 'function';\n}\n/**\n * @param {?} target\n * @param {?} propertyName\n * @return {?}\n */\nfunction hasOwnProperty(target, propertyName) {\n  return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} reducer\n * @param {?} checks\n * @return {?}\n */\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n  return (\n    /**\n    * @param {?} state\n    * @param {?} action\n    * @return {?}\n    */\n    function (state, action) {\n      /** @type {?} */\n      const act = checks.action ? freeze(action) : action;\n      /** @type {?} */\n      const nextState = reducer(state, act);\n      return checks.state ? freeze(nextState) : nextState;\n    }\n  );\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction freeze(target) {\n  Object.freeze(target);\n  /** @type {?} */\n  const targetIsFunction = isFunction(target);\n  Object.getOwnPropertyNames(target).forEach(\n  /**\n  * @param {?} prop\n  * @return {?}\n  */\n  prop => {\n    if (hasOwnProperty(target, prop) && (targetIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true)) {\n      /** @type {?} */\n      const propValue = target[prop];\n      if ((isObjectLike(propValue) || isFunction(propValue)) && !Object.isFrozen(propValue)) {\n        freeze(propValue);\n      }\n    }\n  });\n  return target;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} reducer\n * @param {?} checks\n * @return {?}\n */\nfunction serializationCheckMetaReducer(reducer, checks) {\n  return (\n    /**\n    * @param {?} state\n    * @param {?} action\n    * @return {?}\n    */\n    function (state, action) {\n      if (checks.action) {\n        /** @type {?} */\n        const unserializableAction = getUnserializable(action);\n        throwIfUnserializable(unserializableAction, 'action');\n      }\n      /** @type {?} */\n      const nextState = reducer(state, action);\n      if (checks.state) {\n        /** @type {?} */\n        const unserializableState = getUnserializable(nextState);\n        throwIfUnserializable(unserializableState, 'state');\n      }\n      return nextState;\n    }\n  );\n}\n/**\n * @param {?=} target\n * @param {?=} path\n * @return {?}\n */\nfunction getUnserializable(target, path = []) {\n  // Guard against undefined and null, e.g. a reducer that returns undefined\n  if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n    return {\n      path: ['root'],\n      value: target\n    };\n  }\n  /** @type {?} */\n  const keys = Object.keys(target);\n  return keys.reduce(\n  /**\n  * @param {?} result\n  * @param {?} key\n  * @return {?}\n  */\n  (result, key) => {\n    if (result) {\n      return result;\n    }\n    /** @type {?} */\n    const value = ( /** @type {?} */target)[key];\n    if (isUndefined(value) || isNull(value) || isNumber(value) || isBoolean(value) || isString(value) || isArray(value)) {\n      return false;\n    }\n    if (isPlainObject(value)) {\n      return getUnserializable(value, [...path, key]);\n    }\n    return {\n      path: [...path, key],\n      value\n    };\n  }, false);\n}\n/**\n * @param {?} unserializable\n * @param {?} context\n * @return {?}\n */\nfunction throwIfUnserializable(unserializable, context) {\n  if (unserializable === false) {\n    return;\n  }\n  /** @type {?} */\n  const unserializablePath = unserializable.path.join('.');\n  /** @type {?} */\n  const error = new Error(`Detected unserializable ${context} at \"${unserializablePath}\"`);\n  error.value = unserializable.value;\n  error.unserializablePath = unserializablePath;\n  throw error;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?=} runtimeChecks\n * @return {?}\n */\nfunction createActiveRuntimeChecks(runtimeChecks) {\n  if (isDevMode()) {\n    if (runtimeChecks === undefined) {\n      console.warn('@ngrx/store: runtime checks are currently opt-in but will be the default in the next major version with the possibility to opt-out, see https://ngrx.io/guide/migration/v8 for more information.');\n    }\n    return Object.assign({\n      strictStateSerializability: false,\n      strictActionSerializability: false,\n      strictStateImmutability: false,\n      strictActionImmutability: false\n    }, runtimeChecks);\n  }\n  return {\n    strictStateSerializability: false,\n    strictActionSerializability: false,\n    strictStateImmutability: false,\n    strictActionImmutability: false\n  };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createSerializationCheckMetaReducer({\n  strictActionSerializability,\n  strictStateSerializability\n}) {\n  return (\n    /**\n    * @param {?} reducer\n    * @return {?}\n    */\n    reducer => strictActionSerializability || strictStateSerializability ? serializationCheckMetaReducer(reducer, {\n      action: strictActionSerializability,\n      state: strictStateSerializability\n    }) : reducer\n  );\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createImmutabilityCheckMetaReducer({\n  strictActionImmutability,\n  strictStateImmutability\n}) {\n  return (\n    /**\n    * @param {?} reducer\n    * @return {?}\n    */\n    reducer => strictActionImmutability || strictStateImmutability ? immutabilityCheckMetaReducer(reducer, {\n      action: strictActionImmutability,\n      state: strictStateImmutability\n    }) : reducer\n  );\n}\n/**\n * @param {?=} runtimeChecks\n * @return {?}\n */\nfunction provideRuntimeChecks(runtimeChecks) {\n  return [{\n    provide: _USER_RUNTIME_CHECKS,\n    useValue: runtimeChecks\n  }, {\n    provide: USER_RUNTIME_CHECKS,\n    useFactory: _runtimeChecksFactory,\n    deps: [_USER_RUNTIME_CHECKS]\n  }, {\n    provide: _ACTIVE_RUNTIME_CHECKS,\n    deps: [USER_RUNTIME_CHECKS],\n    useFactory: createActiveRuntimeChecks\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [_ACTIVE_RUNTIME_CHECKS],\n    useFactory: createImmutabilityCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [_ACTIVE_RUNTIME_CHECKS],\n    useFactory: createSerializationCheckMetaReducer\n  }];\n}\n/**\n * @param {?} runtimeChecks\n * @return {?}\n */\nfunction _runtimeChecksFactory(runtimeChecks) {\n  return runtimeChecks;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass StoreRootModule {\n  /**\n   * @param {?} actions$\n   * @param {?} reducer$\n   * @param {?} scannedActions$\n   * @param {?} store\n   * @param {?} guard\n   */\n  constructor(actions$, reducer$, scannedActions$, store, guard) {}\n}\n\n/** @nocollapse */\n\nclass StoreFeatureModule {\n  /**\n   * @param {?} features\n   * @param {?} featureReducers\n   * @param {?} reducerManager\n   * @param {?} root\n   */\n  constructor(features, featureReducers, reducerManager, root) {\n    this.features = features;\n    this.featureReducers = featureReducers;\n    this.reducerManager = reducerManager;\n    /** @type {?} */\n    const feats = features.map(\n    /**\n    * @param {?} feature\n    * @param {?} index\n    * @return {?}\n    */\n    (feature, index) => {\n      /** @type {?} */\n      const featureReducerCollection = featureReducers.shift();\n      /** @type {?} */\n      const reducers = ( /** @type {?} */featureReducerCollection /*TODO(#823)*/)[index];\n      return Object.assign({}, feature, {\n        reducers,\n        initialState: _initialStateFactory(feature.initialState)\n      });\n    });\n    reducerManager.addFeatures(feats);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.reducerManager.removeFeatures(this.features);\n  }\n}\n\n/** @nocollapse */\n\nclass StoreModule {\n  /**\n   * @param {?} reducers\n   * @param {?=} config\n   * @return {?}\n   */\n  static forRoot(reducers, config = {}) {\n    return {\n      ngModule: StoreRootModule,\n      providers: [{\n        provide: _ROOT_STORE_GUARD,\n        useFactory: _provideForRootGuard,\n        deps: [[Store, new Optional(), new SkipSelf()]]\n      }, {\n        provide: _INITIAL_STATE,\n        useValue: config.initialState\n      }, {\n        provide: INITIAL_STATE,\n        useFactory: _initialStateFactory,\n        deps: [_INITIAL_STATE]\n      }, {\n        provide: _INITIAL_REDUCERS,\n        useValue: reducers\n      }, {\n        provide: _STORE_REDUCERS,\n        useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS\n      }, {\n        provide: INITIAL_REDUCERS,\n        deps: [Injector, _INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n        useFactory: _createStoreReducers\n      }, {\n        provide: USER_PROVIDED_META_REDUCERS,\n        useValue: config.metaReducers ? config.metaReducers : []\n      }, {\n        provide: _RESOLVED_META_REDUCERS,\n        deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n        useFactory: _concatMetaReducers\n      }, {\n        provide: _REDUCER_FACTORY,\n        useValue: config.reducerFactory ? config.reducerFactory : combineReducers\n      }, {\n        provide: REDUCER_FACTORY,\n        deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n        useFactory: createReducerFactory\n      }, ACTIONS_SUBJECT_PROVIDERS, REDUCER_MANAGER_PROVIDERS, SCANNED_ACTIONS_SUBJECT_PROVIDERS, STATE_PROVIDERS, STORE_PROVIDERS, provideRuntimeChecks(config.runtimeChecks)]\n    };\n  }\n  /**\n   * @param {?} featureName\n   * @param {?} reducers\n   * @param {?=} config\n   * @return {?}\n   */\n  static forFeature(featureName, reducers, config = {}) {\n    return {\n      ngModule: StoreFeatureModule,\n      providers: [{\n        provide: _FEATURE_CONFIGS,\n        multi: true,\n        useValue: config\n      }, {\n        provide: STORE_FEATURES,\n        multi: true,\n        useValue: {\n          key: featureName,\n          reducerFactory: !(config instanceof InjectionToken) && config.reducerFactory ? config.reducerFactory : combineReducers,\n          metaReducers: !(config instanceof InjectionToken) && config.metaReducers ? config.metaReducers : [],\n          initialState: !(config instanceof InjectionToken) && config.initialState ? config.initialState : undefined\n        }\n      }, {\n        provide: _STORE_FEATURES,\n        deps: [Injector, _FEATURE_CONFIGS, STORE_FEATURES],\n        useFactory: _createFeatureStore\n      }, {\n        provide: _FEATURE_REDUCERS,\n        multi: true,\n        useValue: reducers\n      }, {\n        provide: _FEATURE_REDUCERS_TOKEN,\n        multi: true,\n        useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS\n      }, {\n        provide: FEATURE_REDUCERS,\n        multi: true,\n        deps: [Injector, _FEATURE_REDUCERS, [new Inject(_FEATURE_REDUCERS_TOKEN)]],\n        useFactory: _createFeatureReducers\n      }]\n    };\n  }\n}\n/**\n * @param {?} injector\n * @param {?} reducers\n * @return {?}\n */\nfunction _createStoreReducers(injector, reducers) {\n  return reducers instanceof InjectionToken ? injector.get(reducers) : reducers;\n}\n/**\n * @param {?} injector\n * @param {?} configs\n * @param {?} featureStores\n * @return {?}\n */\nfunction _createFeatureStore(injector, configs, featureStores) {\n  return featureStores.map(\n  /**\n  * @param {?} feat\n  * @param {?} index\n  * @return {?}\n  */\n  (feat, index) => {\n    if (configs[index] instanceof InjectionToken) {\n      /** @type {?} */\n      const conf = injector.get(configs[index]);\n      return {\n        key: feat.key,\n        reducerFactory: conf.reducerFactory ? conf.reducerFactory : combineReducers,\n        metaReducers: conf.metaReducers ? conf.metaReducers : [],\n        initialState: conf.initialState\n      };\n    }\n    return feat;\n  });\n}\n/**\n * @param {?} injector\n * @param {?} reducerCollection\n * @return {?}\n */\nfunction _createFeatureReducers(injector, reducerCollection) {\n  /** @type {?} */\n  const reducers = reducerCollection.map(\n  /**\n  * @param {?} reducer\n  * @return {?}\n  */\n  reducer => {\n    return reducer instanceof InjectionToken ? injector.get(reducer) : reducer;\n  });\n  return reducers;\n}\n/**\n * @param {?} initialState\n * @return {?}\n */\nfunction _initialStateFactory(initialState) {\n  if (typeof initialState === 'function') {\n    return initialState();\n  }\n  return initialState;\n}\n/**\n * @param {?} metaReducers\n * @param {?} userProvidedMetaReducers\n * @return {?}\n */\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n  return metaReducers.concat(userProvidedMetaReducers);\n}\n/**\n * @param {?} store\n * @return {?}\n */\nfunction _provideForRootGuard(store) {\n  if (store) {\n    throw new TypeError(`StoreModule.forRoot() called twice. Feature modules should use StoreModule.forFeature() instead.`);\n  }\n  return 'guarded';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@description\n * Associates actions with a given state change function.\n * A state change function must be provided as the last parameter.\n *\n * @param {...?} args `ActionCreator`'s followed by a state change function.\n *\n * **To maintain type-safety**: pass 10 or less `ActionCreator`'s.\n * @return {?} an association of action types with a state change function.\n */\nfunction on(...args) {\n  /** @type {?} */\n  const reducer = /** @type {?} */args.pop();\n  /** @type {?} */\n  const types = args.reduce(\n  /**\n  * @param {?} result\n  * @param {?} creator\n  * @return {?}\n  */\n  (result, creator) => [...result, ( /** @type {?} */creator).type], /** @type {?} */[]);\n  return {\n    reducer,\n    types\n  };\n}\n/**\n * \\@description\n * Creates a reducer function to handle state transitions.\n *\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\n *\n * \\@usageNotes\n *\n * - Must be used with `ActionCreator`'s (returned by `createAction`).  Cannot be used with class-based action creators.\n * - An action can be associated with multiple state change functions. In this case the functions will be executed in the specified order.\n * - The returned `ActionReducer` should additionally be returned from an exported `reducer` function.\n * This is because [function calls are not supported](https://angular.io/guide/aot-compiler#function-calls-are-not-supported) by the AOT compiler.\n *\n * **Declaring a reducer creator with an exported reducer function**\n *\n * ```ts\n * const featureReducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n *\n * export function reducer(state: State | undefined, action: Action) {\n *   return featureReducer(state, action);\n * }\n * ```\n * @template S, A\n * @param {?} initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @param {...?} ons Associations between actions and state changes.\n * @return {?} A reducer function.\n *\n */\nfunction createReducer(initialState, ...ons) {\n  /** @type {?} */\n  const map = new Map();\n  for (let on of ons) {\n    for (let type of on.types) {\n      if (map.has(type)) {\n        /** @type {?} */\n        const existingReducer = /** @type {?} */map.get(type);\n        /** @type {?} */\n        const newReducer =\n        /**\n        * @param {?} state\n        * @param {?} action\n        * @return {?}\n        */\n        (state, action) => on.reducer(existingReducer(state, action), action);\n        map.set(type, newReducer);\n      } else {\n        map.set(type, on.reducer);\n      }\n    }\n  }\n  return (\n    /**\n    * @param {?=} state\n    * @param {?=} action\n    * @return {?}\n    */\n    function (state = initialState, action) {\n      /** @type {?} */\n      const reducer = map.get(action.type);\n      return reducer ? reducer(state, action) : state;\n    }\n  );\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ACTIONS_SUBJECT_PROVIDERS as ɵngrx_modules_store_store_c, REDUCER_MANAGER_PROVIDERS as ɵngrx_modules_store_store_d, _runtimeChecksFactory as ɵngrx_modules_store_store_bd, createActiveRuntimeChecks as ɵngrx_modules_store_store_z, createImmutabilityCheckMetaReducer as ɵngrx_modules_store_store_bb, createSerializationCheckMetaReducer as ɵngrx_modules_store_store_ba, provideRuntimeChecks as ɵngrx_modules_store_store_bc, SCANNED_ACTIONS_SUBJECT_PROVIDERS as ɵngrx_modules_store_store_e, isEqualCheck as ɵngrx_modules_store_store_f, STATE_PROVIDERS as ɵngrx_modules_store_store_g, STORE_PROVIDERS as ɵngrx_modules_store_store_b, _concatMetaReducers as ɵngrx_modules_store_store_x, _createFeatureReducers as ɵngrx_modules_store_store_v, _createFeatureStore as ɵngrx_modules_store_store_u, _createStoreReducers as ɵngrx_modules_store_store_t, _initialStateFactory as ɵngrx_modules_store_store_w, _provideForRootGuard as ɵngrx_modules_store_store_y, _ACTIVE_RUNTIME_CHECKS as ɵngrx_modules_store_store_s, _FEATURE_CONFIGS as ɵngrx_modules_store_store_n, _FEATURE_REDUCERS as ɵngrx_modules_store_store_m, _FEATURE_REDUCERS_TOKEN as ɵngrx_modules_store_store_p, _INITIAL_REDUCERS as ɵngrx_modules_store_store_k, _INITIAL_STATE as ɵngrx_modules_store_store_i, _REDUCER_FACTORY as ɵngrx_modules_store_store_j, _RESOLVED_META_REDUCERS as ɵngrx_modules_store_store_q, _ROOT_STORE_GUARD as ɵngrx_modules_store_store_h, _STORE_FEATURES as ɵngrx_modules_store_store_o, _STORE_REDUCERS as ɵngrx_modules_store_store_l, _USER_RUNTIME_CHECKS as ɵngrx_modules_store_store_r, createAction, props, union, Store, select, combineReducers, compose, createReducerFactory, ActionsSubject, INIT, ReducerManager, ReducerObservable, ReducerManagerDispatcher, UPDATE, ScannedActionsSubject, createSelector, createSelectorFactory, createFeatureSelector, defaultMemoize, defaultStateFn, resultMemoize, State, StateObservable, reduceState, INITIAL_STATE, REDUCER_FACTORY, INITIAL_REDUCERS, STORE_FEATURES, META_REDUCERS, FEATURE_REDUCERS, USER_PROVIDED_META_REDUCERS, USER_RUNTIME_CHECKS, StoreModule, StoreRootModule, StoreFeatureModule, on, createReducer };\n//# sourceMappingURL=store.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}