{"ast":null,"code":"/**\n * @license NgRx 8.6.1\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { InjectionToken, Injectable, Inject, ErrorHandler, NgModule } from '@angular/core';\nimport { ActionsSubject, UPDATE, INIT, ReducerObservable, ScannedActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { empty, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass StoreDevtoolsConfig {}\n/** @type {?} */\nconst STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/devtools Options');\n/** @type {?} */\nconst INITIAL_OPTIONS = new InjectionToken('@ngrx/devtools Initial Config');\n/**\n * @return {?}\n */\nfunction noMonitor() {\n  return null;\n}\n/** @type {?} */\nconst DEFAULT_NAME = 'NgRx Store DevTools';\n/**\n * @param {?} _options\n * @return {?}\n */\nfunction createConfig(_options) {\n  /** @type {?} */\n  const DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      // start/pause recording of dispatched actions\n      lock: true,\n      // lock/unlock dispatching actions and side effects\n      persist: true,\n      // persist states on page reloading\n      export: true,\n      // export history of actions in a file\n      import: 'custom',\n      // import history of actions from a file\n      jump: true,\n      // jump back and forth (time travelling)\n      skip: true,\n      // skip (cancel) actions\n      reorder: true,\n      // drag and drop actions in the history list\n      dispatch: true,\n      // dispatch custom actions or action creators\n      test: true\n    }\n  };\n  /** @type {?} */\n  let options = typeof _options === 'function' ? _options() : _options;\n  /** @type {?} */\n  const logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  /** @type {?} */\n  const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  /** @type {?} */\n  const config = Object.assign({}, DEFAULT_OPTIONS, {\n    features\n  }, options);\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n  }\n  return config;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst PERFORM_ACTION = 'PERFORM_ACTION';\n/** @type {?} */\nconst REFRESH = 'REFRESH';\n/** @type {?} */\nconst RESET = 'RESET';\n/** @type {?} */\nconst ROLLBACK = 'ROLLBACK';\n/** @type {?} */\nconst COMMIT = 'COMMIT';\n/** @type {?} */\nconst SWEEP = 'SWEEP';\n/** @type {?} */\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\n/** @type {?} */\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\n/** @type {?} */\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\n/** @type {?} */\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\n/** @type {?} */\nconst IMPORT_STATE = 'IMPORT_STATE';\n/** @type {?} */\nconst LOCK_CHANGES = 'LOCK_CHANGES';\n/** @type {?} */\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\nclass PerformAction {\n  /**\n   * @param {?} action\n   * @param {?} timestamp\n   */\n  constructor(action, timestamp) {\n    this.action = action;\n    this.timestamp = timestamp;\n    this.type = PERFORM_ACTION;\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n  }\n}\nclass Refresh {\n  constructor() {\n    this.type = REFRESH;\n  }\n}\nclass Reset {\n  /**\n   * @param {?} timestamp\n   */\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = RESET;\n  }\n}\nclass Rollback {\n  /**\n   * @param {?} timestamp\n   */\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = ROLLBACK;\n  }\n}\nclass Commit {\n  /**\n   * @param {?} timestamp\n   */\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = COMMIT;\n  }\n}\nclass Sweep {\n  constructor() {\n    this.type = SWEEP;\n  }\n}\nclass ToggleAction {\n  /**\n   * @param {?} id\n   */\n  constructor(id) {\n    this.id = id;\n    this.type = TOGGLE_ACTION;\n  }\n}\nclass JumpToState {\n  /**\n   * @param {?} index\n   */\n  constructor(index) {\n    this.index = index;\n    this.type = JUMP_TO_STATE;\n  }\n}\nclass JumpToAction {\n  /**\n   * @param {?} actionId\n   */\n  constructor(actionId) {\n    this.actionId = actionId;\n    this.type = JUMP_TO_ACTION;\n  }\n}\nclass ImportState {\n  /**\n   * @param {?} nextLiftedState\n   */\n  constructor(nextLiftedState) {\n    this.nextLiftedState = nextLiftedState;\n    this.type = IMPORT_STATE;\n  }\n}\nclass LockChanges {\n  /**\n   * @param {?} status\n   */\n  constructor(status) {\n    this.status = status;\n    this.type = LOCK_CHANGES;\n  }\n}\nclass PauseRecording {\n  /**\n   * @param {?} status\n   */\n  constructor(status) {\n    this.status = status;\n    this.type = PAUSE_RECORDING;\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DevtoolsDispatcher extends ActionsSubject {}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} first\n * @param {?} second\n * @return {?}\n */\nfunction difference(first, second) {\n  return first.filter(\n  /**\n  * @param {?} item\n  * @return {?}\n  */\n  item => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n * @param {?} liftedState\n * @return {?}\n */\nfunction unliftState(liftedState) {\n  const {\n    computedStates,\n    currentStateIndex\n  } = liftedState;\n  // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n  if (currentStateIndex >= computedStates.length) {\n    const {\n      state\n    } = computedStates[computedStates.length - 1];\n    return state;\n  }\n  const {\n    state\n  } = computedStates[currentStateIndex];\n  return state;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n * @param {?} action\n * @return {?}\n */\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n * @param {?} actionSanitizer\n * @param {?} actions\n * @return {?}\n */\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce(\n  /**\n  * @param {?} sanitizedActions\n  * @param {?} actionIdx\n  * @return {?}\n  */\n  (sanitizedActions, actionIdx) => {\n    /** @type {?} */\n    const idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, /** @type {?} */{});\n}\n/**\n * Sanitizes given action with given function.\n * @param {?} actionSanitizer\n * @param {?} action\n * @param {?} actionIdx\n * @return {?}\n */\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return Object.assign({}, action, {\n    action: actionSanitizer(action.action, actionIdx)\n  });\n}\n/**\n * Sanitizes given states with given function.\n * @param {?} stateSanitizer\n * @param {?} states\n * @return {?}\n */\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map(\n  /**\n  * @param {?} computedState\n  * @param {?} idx\n  * @return {?}\n  */\n  (computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error\n  }));\n}\n/**\n * Sanitizes given state with given function.\n * @param {?} stateSanitizer\n * @param {?} state\n * @param {?} stateIdx\n * @return {?}\n */\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n * @param {?} config\n * @return {?}\n */\nfunction shouldFilterActions(config) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n * @param {?} liftedState\n * @param {?=} predicate\n * @param {?=} safelist\n * @param {?=} blocklist\n * @return {?}\n */\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  /** @type {?} */\n  const filteredStagedActionIds = [];\n  /** @type {?} */\n  const filteredActionsById = {};\n  /** @type {?} */\n  const filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach(\n  /**\n  * @param {?} id\n  * @param {?} idx\n  * @return {?}\n  */\n  (id, idx) => {\n    /** @type {?} */\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return Object.assign({}, liftedState, {\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  });\n}\n/**\n * Return true is the action should be ignored\n * @param {?} state\n * @param {?} action\n * @param {?=} predicate\n * @param {?=} safelist\n * @param {?=} blockedlist\n * @return {?}\n */\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  /** @type {?} */\n  const predicateMatch = predicate && !predicate(state, action.action);\n  /** @type {?} */\n  const safelistMatch = safelist && !action.action.type.match(safelist.map(\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  s => escapeRegExp(s)).join('|'));\n  /** @type {?} */\n  const blocklistMatch = blockedlist && action.action.type.match(blockedlist.map(\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  s => escapeRegExp(s)).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n * @param {?} s\n * @return {?}\n */\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION'\n};\n/** @type {?} */\nconst REDUX_DEVTOOLS_EXTENSION = new InjectionToken('Redux Devtools Extension');\nclass DevtoolsExtension {\n  /**\n   * @param {?} devtoolsExtension\n   * @param {?} config\n   * @param {?} dispatcher\n   */\n  constructor(devtoolsExtension, config, dispatcher) {\n    this.config = config;\n    this.dispatcher = dispatcher;\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n  /**\n   * @param {?} action\n   * @param {?} state\n   * @return {?}\n   */\n  notify(action, state) {\n    if (!this.devtoolsExtension) {\n      return;\n    }\n    // Check to see if the action requires a full update of the liftedState.\n    // If it is a simple action generated by the user's app and the recording\n    // is not locked/paused, only send the action and the current state (fast).\n    //\n    // A full liftedState update (slow: serializes the entire liftedState) is\n    // only required when:\n    //   a) redux-devtools-extension fires the @@Init action (ignored by\n    //      @ngrx/store-devtools)\n    //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n    //      or @ngrx/store/update-reducers)\n    //   c) the state has been recomputed due to time-traveling\n    //   d) any action that is not a PerformAction to err on the side of\n    //      caution.\n    if (action.type === PERFORM_ACTION) {\n      if (state.isLocked || state.isPaused) {\n        return;\n      }\n      /** @type {?} */\n      const currentState = unliftState(state);\n      if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n        return;\n      }\n      /** @type {?} */\n      const sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n      /** @type {?} */\n      const sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n      this.sendToReduxDevtools(\n      /**\n      * @return {?}\n      */\n      () => this.extensionConnection.send(sanitizedAction, sanitizedState));\n    } else {\n      // Requires full state update\n      /** @type {?} */\n      const sanitizedLiftedState = Object.assign({}, state, {\n        stagedActionIds: state.stagedActionIds,\n        actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n        computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n      });\n      this.sendToReduxDevtools(\n      /**\n      * @return {?}\n      */\n      () => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n    }\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n  createChangesObservable() {\n    if (!this.devtoolsExtension) {\n      return empty();\n    }\n    return new Observable(\n    /**\n    * @param {?} subscriber\n    * @return {?}\n    */\n    subscriber => {\n      /** @type {?} */\n      const connection = this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n      this.extensionConnection = connection;\n      connection.init();\n      connection.subscribe(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => subscriber.next(change));\n      return connection.unsubscribe;\n    });\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n  createActionStreams() {\n    // Listens to all changes\n    /** @type {?} */\n    const changes$ = this.createChangesObservable().pipe(share());\n    // Listen for the start action\n    /** @type {?} */\n    const start$ = changes$.pipe(filter(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    change => change.type === ExtensionActionTypes.START));\n    // Listen for the stop action\n    /** @type {?} */\n    const stop$ = changes$.pipe(filter(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    change => change.type === ExtensionActionTypes.STOP));\n    // Listen for lifted actions\n    /** @type {?} */\n    const liftedActions$ = changes$.pipe(filter(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    change => change.type === ExtensionActionTypes.DISPATCH), map(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    change => this.unwrapAction(change.payload)), concatMap(\n    /**\n    * @param {?} action\n    * @return {?}\n    */\n    action => {\n      if (action.type === IMPORT_STATE) {\n        // State imports may happen in two situations:\n        // 1. Explicitly by user\n        // 2. User activated the \"persist state accross reloads\" option\n        //    and now the state is imported during reload.\n        // Because of option 2, we need to give possible\n        // lazy loaded reducers time to instantiate.\n        // As soon as there is no UPDATE action within 1 second,\n        // it is assumed that all reducers are loaded.\n        return this.dispatcher.pipe(filter(\n        /**\n        * @param {?} action\n        * @return {?}\n        */\n        action => action.type === UPDATE), timeout(1000), debounceTime(1000), map(\n        /**\n        * @return {?}\n        */\n        () => action), catchError(\n        /**\n        * @return {?}\n        */\n        () => of(action)), take(1));\n      } else {\n        return of(action);\n      }\n    }));\n    // Listen for unlifted actions\n    /** @type {?} */\n    const actions$ = changes$.pipe(filter(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    change => change.type === ExtensionActionTypes.ACTION), map(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    change => this.unwrapAction(change.payload)));\n    /** @type {?} */\n    const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n    /** @type {?} */\n    const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n    this.start$ = start$.pipe(takeUntil(stop$));\n    // Only take the action sources between the start/stop events\n    this.actions$ = this.start$.pipe(switchMap(\n    /**\n    * @return {?}\n    */\n    () => actionsUntilStop$));\n    this.liftedActions$ = this.start$.pipe(switchMap(\n    /**\n    * @return {?}\n    */\n    () => liftedUntilStop$));\n  }\n  /**\n   * @private\n   * @param {?} action\n   * @return {?}\n   */\n  unwrapAction(action) {\n    return typeof action === 'string' ? eval(`(${action})`) : action;\n  }\n  /**\n   * @private\n   * @param {?} config\n   * @return {?}\n   */\n  getExtensionConfig(config) {\n    /** @type {?} */\n    const extensionOptions = {\n      name: config.name,\n      features: config.features,\n      serialize: config.serialize\n    };\n    if (config.maxAge !== false /* support === 0 */) {\n      extensionOptions.maxAge = config.maxAge;\n    }\n    return extensionOptions;\n  }\n  /**\n   * @private\n   * @param {?} send\n   * @return {?}\n   */\n  sendToReduxDevtools(send) {\n    try {\n      send();\n    } catch (err) {\n      console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst INIT_ACTION = {\n  type: INIT\n};\n/** @type {?} */\nconst RECOMPUTE = /** @type {?} */'@ngrx/store-devtools/recompute';\n/** @type {?} */\nconst RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\n/**\n * Computes the next entry in the log by applying an action.\n * @param {?} reducer\n * @param {?} action\n * @param {?} state\n * @param {?} error\n * @param {?} errorHandler\n * @return {?}\n */\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n  /** @type {?} */\n  let nextState = state;\n  /** @type {?} */\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err.stack || err);\n  }\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n * @param {?} computedStates\n * @param {?} minInvalidatedStateIndex\n * @param {?} reducer\n * @param {?} committedState\n * @param {?} actionsById\n * @param {?} stagedActionIds\n * @param {?} skippedActionIds\n * @param {?} errorHandler\n * @param {?} isPaused\n * @return {?}\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  /** @type {?} */\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n  /** @type {?} */\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    /** @type {?} */\n    const actionId = stagedActionIds[i];\n    /** @type {?} */\n    const action = actionsById[actionId].action;\n    /** @type {?} */\n    const previousEntry = nextComputedStates[i - 1];\n    /** @type {?} */\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    /** @type {?} */\n    const previousError = previousEntry ? previousEntry.error : undefined;\n    /** @type {?} */\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    /** @type {?} */\n    const entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n    nextComputedStates.push(entry);\n  }\n  // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n  return nextComputedStates;\n}\n/**\n * @param {?=} initialCommittedState\n * @param {?=} monitorReducer\n * @return {?}\n */\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n * @param {?} initialCommittedState\n * @param {?} initialLiftedState\n * @param {?} errorHandler\n * @param {?=} monitorReducer\n * @param {?=} options\n * @return {?}\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n    /**\n    * @param {?} reducer\n    * @return {?}\n    */\n    reducer => (\n    /**\n    * @param {?} liftedState\n    * @param {?} liftedAction\n    * @return {?}\n    */\n    (liftedState, liftedAction) => {\n      let {\n        monitorState,\n        actionsById,\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates,\n        isLocked,\n        isPaused\n      } = liftedState || initialLiftedState;\n      if (!liftedState) {\n        // Prevent mutating initialLiftedState\n        actionsById = Object.create(actionsById);\n      }\n      /**\n       * @param {?} n\n       * @return {?}\n       */\n      function commitExcessActions(n) {\n        // Auto-commits n-number of excess actions.\n        /** @type {?} */\n        let excess = n;\n        /** @type {?} */\n        let idsToDelete = stagedActionIds.slice(1, excess + 1);\n        for (let i = 0; i < idsToDelete.length; i++) {\n          if (computedStates[i + 1].error) {\n            // Stop if error is found. Commit actions up to error.\n            excess = i;\n            idsToDelete = stagedActionIds.slice(1, excess + 1);\n            break;\n          } else {\n            delete actionsById[idsToDelete[i]];\n          }\n        }\n        skippedActionIds = skippedActionIds.filter(\n        /**\n        * @param {?} id\n        * @return {?}\n        */\n        id => idsToDelete.indexOf(id) === -1);\n        stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n        committedState = computedStates[excess].state;\n        computedStates = computedStates.slice(excess);\n        currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n      }\n      /**\n       * @return {?}\n       */\n      function commitChanges() {\n        // Consider the last committed state the new starting point.\n        // Squash any staged actions into a single committed state.\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      }\n      // By default, aggressively recompute every state whatever happens.\n      // This has O(n) performance, so we'll override this to a sensible\n      // value whenever we feel like we don't have to recompute the states.\n      /** @type {?} */\n      let minInvalidatedStateIndex = 0;\n      switch (liftedAction.type) {\n        case LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n            if (isPaused) {\n              // Add a pause action to signal the devtools-user the recording is paused.\n              // The corresponding state will be overwritten on each update to always contain\n              // the latest state (see Actions.PERFORM_ACTION).\n              stagedActionIds = [...stagedActionIds, nextActionId];\n              actionsById[nextActionId] = new PerformAction({\n                type: '@ngrx/devtools/pause'\n              }, +Date.now());\n              nextActionId++;\n              minInvalidatedStateIndex = stagedActionIds.length - 1;\n              computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n              if (currentStateIndex === stagedActionIds.length - 2) {\n                currentStateIndex++;\n              }\n              minInvalidatedStateIndex = Infinity;\n            } else {\n              commitChanges();\n            }\n            break;\n          }\n        case RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case COMMIT:\n          {\n            commitChanges();\n            break;\n          }\n        case ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            const {\n              id: actionId\n            } = liftedAction;\n            /** @type {?} */\n            const index = skippedActionIds.indexOf(actionId);\n            if (index === -1) {\n              skippedActionIds = [actionId, ...skippedActionIds];\n            } else {\n              skippedActionIds = skippedActionIds.filter(\n              /**\n              * @param {?} id\n              * @return {?}\n              */\n              id => id !== actionId);\n            }\n            // Optimization: we know history before this action hasn't changed\n            minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n            break;\n          }\n        case SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            const {\n              start,\n              end,\n              active\n            } = liftedAction;\n            /** @type {?} */\n            const actionIds = [];\n            for (let i = start; i < end; i++) actionIds.push(i);\n            if (active) {\n              skippedActionIds = difference(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = [...skippedActionIds, ...actionIds];\n            }\n            // Optimization: we know history before this action hasn't changed\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n        case JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index;\n            // Optimization: we know the history has not changed.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            /** @type {?} */\n            const index = stagedActionIds.indexOf(liftedAction.actionId);\n            if (index !== -1) currentStateIndex = index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = difference(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n        case PERFORM_ACTION:\n          {\n            // Ignore action and return state as is if recording is locked\n            if (isLocked) {\n              return liftedState || initialLiftedState;\n            }\n            if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n              // If recording is paused or if the action should be ignored, overwrite the last state\n              // (corresponds to the pause action) and keep everything else as is.\n              // This way, the app gets the new current state while the devtools\n              // do not record another action.\n              /** @type {?} */\n              const lastState = computedStates[computedStates.length - 1];\n              computedStates = [...computedStates.slice(0, -1), computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)];\n              minInvalidatedStateIndex = Infinity;\n              break;\n            }\n            // Auto-commit as new actions come in.\n            if (options.maxAge && stagedActionIds.length === options.maxAge) {\n              commitExcessActions(1);\n            }\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n            /** @type {?} */\n            const actionId = nextActionId++;\n            // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n            actionsById[actionId] = liftedAction;\n            stagedActionIds = [...stagedActionIds, actionId];\n            // Optimization: we know that only the new action needs computing.\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n        case IMPORT_STATE:\n          {\n            // Completely replace everything.\n            ({\n              monitorState,\n              actionsById,\n              nextActionId,\n              stagedActionIds,\n              skippedActionIds,\n              committedState,\n              currentStateIndex,\n              computedStates,\n              isLocked,\n              // prettier-ignore\n              isPaused\n            } = liftedAction.nextLiftedState);\n            break;\n          }\n        case INIT:\n          {\n            // Always recompute states on hot reload and init.\n            minInvalidatedStateIndex = 0;\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              // States must be recomputed before committing excess.\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              commitExcessActions(stagedActionIds.length - options.maxAge);\n              // Avoid double computation.\n              minInvalidatedStateIndex = Infinity;\n            }\n            break;\n          }\n        case UPDATE:\n          {\n            /** @type {?} */\n            const stateHasErrors = computedStates.filter(\n            /**\n            * @param {?} state\n            * @return {?}\n            */\n            state => state.error).length > 0;\n            if (stateHasErrors) {\n              // Recompute all states\n              minInvalidatedStateIndex = 0;\n              if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                // States must be recomputed before committing excess.\n                computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                commitExcessActions(stagedActionIds.length - options.maxAge);\n                // Avoid double computation.\n                minInvalidatedStateIndex = Infinity;\n              }\n            } else {\n              // If not paused/locked, add a new action to signal devtools-user\n              // that there was a reducer update.\n              if (!isPaused && !isLocked) {\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                  currentStateIndex++;\n                }\n                // Add a new action to only recompute state\n                /** @type {?} */\n                const actionId = nextActionId++;\n                actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n                stagedActionIds = [...stagedActionIds, actionId];\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              }\n              // Recompute state history with latest reducer and update action\n              computedStates = computedStates.map(\n              /**\n              * @param {?} cmp\n              * @return {?}\n              */\n              cmp => Object.assign({}, cmp, {\n                state: reducer(cmp.state, RECOMPUTE_ACTION)\n              }));\n              currentStateIndex = stagedActionIds.length - 1;\n              if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                commitExcessActions(stagedActionIds.length - options.maxAge);\n              }\n              // Avoid double computation.\n              minInvalidatedStateIndex = Infinity;\n            }\n            break;\n          }\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n      computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n      monitorState = monitorReducer(monitorState, liftedAction);\n      return {\n        monitorState,\n        actionsById,\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates,\n        isLocked,\n        isPaused\n      };\n    })\n  );\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass StoreDevtools {\n  /**\n   * @param {?} dispatcher\n   * @param {?} actions$\n   * @param {?} reducers$\n   * @param {?} extension\n   * @param {?} scannedActions\n   * @param {?} errorHandler\n   * @param {?} initialState\n   * @param {?} config\n   */\n  constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n    /** @type {?} */\n    const liftedInitialState = liftInitialState(initialState, config.monitor);\n    /** @type {?} */\n    const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n    /** @type {?} */\n    const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n    /** @type {?} */\n    const liftedReducer$ = reducers$.pipe(map(liftReducer));\n    /** @type {?} */\n    const liftedStateSubject = new ReplaySubject(1);\n    /** @type {?} */\n    const liftedStateSubscription = liftedAction$.pipe(withLatestFrom(liftedReducer$), scan(\n    /**\n    * @param {?} __0\n    * @param {?} __1\n    * @return {?}\n    */\n    ({\n      state: liftedState\n    }, [action, reducer]) => {\n      /** @type {?} */\n      let reducedLiftedState = reducer(liftedState, action);\n      // On full state update\n      // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n      if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n        reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n      }\n      // Extension should be sent the sanitized lifted state\n      extension.notify(action, reducedLiftedState);\n      return {\n        state: reducedLiftedState,\n        action\n      };\n    }, {\n      state: liftedInitialState,\n      action: ( /** @type {?} */null)\n    })).subscribe(\n    /**\n    * @param {?} __0\n    * @return {?}\n    */\n    ({\n      state,\n      action\n    }) => {\n      liftedStateSubject.next(state);\n      if (action.type === PERFORM_ACTION) {\n        /** @type {?} */\n        const unliftedAction = ( /** @type {?} */action).action;\n        scannedActions.next(unliftedAction);\n      }\n    });\n    /** @type {?} */\n    const extensionStartSubscription = extension.start$.subscribe(\n    /**\n    * @return {?}\n    */\n    () => {\n      this.refresh();\n    });\n    /** @type {?} */\n    const liftedState$ = /** @type {?} */liftedStateSubject.asObservable();\n    /** @type {?} */\n    const state$ = liftedState$.pipe(map(unliftState));\n    this.extensionStartSubscription = extensionStartSubscription;\n    this.stateSubscription = liftedStateSubscription;\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n  /**\n   * @param {?} action\n   * @return {?}\n   */\n  dispatch(action) {\n    this.dispatcher.next(action);\n  }\n  /**\n   * @param {?} action\n   * @return {?}\n   */\n  next(action) {\n    this.dispatcher.next(action);\n  }\n  /**\n   * @param {?} error\n   * @return {?}\n   */\n  error(error) {}\n  /**\n   * @return {?}\n   */\n  complete() {}\n  /**\n   * @param {?} action\n   * @return {?}\n   */\n  performAction(action) {\n    this.dispatch(new PerformAction(action, +Date.now()));\n  }\n  /**\n   * @return {?}\n   */\n  refresh() {\n    this.dispatch(new Refresh());\n  }\n  /**\n   * @return {?}\n   */\n  reset() {\n    this.dispatch(new Reset(+Date.now()));\n  }\n  /**\n   * @return {?}\n   */\n  rollback() {\n    this.dispatch(new Rollback(+Date.now()));\n  }\n  /**\n   * @return {?}\n   */\n  commit() {\n    this.dispatch(new Commit(+Date.now()));\n  }\n  /**\n   * @return {?}\n   */\n  sweep() {\n    this.dispatch(new Sweep());\n  }\n  /**\n   * @param {?} id\n   * @return {?}\n   */\n  toggleAction(id) {\n    this.dispatch(new ToggleAction(id));\n  }\n  /**\n   * @param {?} actionId\n   * @return {?}\n   */\n  jumpToAction(actionId) {\n    this.dispatch(new JumpToAction(actionId));\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n  jumpToState(index) {\n    this.dispatch(new JumpToState(index));\n  }\n  /**\n   * @param {?} nextLiftedState\n   * @return {?}\n   */\n  importState(nextLiftedState) {\n    this.dispatch(new ImportState(nextLiftedState));\n  }\n  /**\n   * @param {?} status\n   * @return {?}\n   */\n  lockChanges(status) {\n    this.dispatch(new LockChanges(status));\n  }\n  /**\n   * @param {?} status\n   * @return {?}\n   */\n  pauseRecording(status) {\n    this.dispatch(new PauseRecording(status));\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('Is Devtools Extension or Monitor Present');\n/**\n * @param {?} extension\n * @param {?} config\n * @return {?}\n */\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n/**\n * @return {?}\n */\nfunction createReduxDevtoolsExtension() {\n  /** @type {?} */\n  const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n  if (typeof window === 'object' && typeof ( /** @type {?} */window)[extensionKey] !== 'undefined') {\n    return ( /** @type {?} */window)[extensionKey];\n  } else {\n    return null;\n  }\n}\n/**\n * @param {?} devtools\n * @return {?}\n */\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\nclass StoreDevtoolsModule {\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n  static instrument(options = {}) {\n    return {\n      ngModule: StoreDevtoolsModule,\n      providers: [DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n        provide: INITIAL_OPTIONS,\n        useValue: options\n      }, {\n        provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n        deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n        useFactory: createIsExtensionOrMonitorPresent\n      }, {\n        provide: REDUX_DEVTOOLS_EXTENSION,\n        useFactory: createReduxDevtoolsExtension\n      }, {\n        provide: STORE_DEVTOOLS_CONFIG,\n        deps: [INITIAL_OPTIONS],\n        useFactory: createConfig\n      }, {\n        provide: StateObservable,\n        deps: [StoreDevtools],\n        useFactory: createStateObservable\n      }, {\n        provide: ReducerManagerDispatcher,\n        useExisting: DevtoolsDispatcher\n      }]\n    };\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_OPTIONS as ɵngrx_modules_store_devtools_store_devtools_f, STORE_DEVTOOLS_CONFIG as ɵngrx_modules_store_devtools_store_devtools_e, createConfig as ɵngrx_modules_store_devtools_store_devtools_h, noMonitor as ɵngrx_modules_store_devtools_store_devtools_g, DevtoolsDispatcher as ɵngrx_modules_store_devtools_store_devtools_k, DevtoolsExtension as ɵngrx_modules_store_devtools_store_devtools_j, REDUX_DEVTOOLS_EXTENSION as ɵngrx_modules_store_devtools_store_devtools_i, IS_EXTENSION_OR_MONITOR_PRESENT as ɵngrx_modules_store_devtools_store_devtools_a, createIsExtensionOrMonitorPresent as ɵngrx_modules_store_devtools_store_devtools_b, createReduxDevtoolsExtension as ɵngrx_modules_store_devtools_store_devtools_c, createStateObservable as ɵngrx_modules_store_devtools_store_devtools_d, StoreDevtoolsModule, RECOMPUTE, StoreDevtools, StoreDevtoolsConfig };\n//# sourceMappingURL=store-devtools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}